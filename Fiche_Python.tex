
\chapter{Python}

\section{Framework and useful}

Anaconda==> Python 3.5

	\code{iPython} script

	\code{Jupyter} machin en ligne


	\subsection{Jupyter notebook}
		\code{jupyter notebook} in cmd

		\code{\%matplotlib inline} makes the graphs in the page

	\subsection{Jupyter console}


		\subsubsection{commands}
			
			\code{ipython} open the jupyter console

			\code{exit} to quit

			\code{\%quickref} gives quick references

			\code{?} help (after a variable for information)

			\code{!command} allows to run shell commands

		\subsubsection{Magics}

			magics are keywords for the jupyter console

			\code{\%run} runs a python script

			\code{\%edit} opens a file editor, typed code is run when exiting

			\code{\%debug} opens a debug window

			\code{\%history}  last few commands

			\code{\%save} save history in a file

			\code{\%who} shows the variables

			\code{\%reset} reset variables

			\code{\%cpaste} opens an environment for pasting code (pasting doesnt work well in line)

			\url{http://ipython.readthedocs.io/en/stable/interactive/magics.html}
	

	\subsection{bash and co}

		\code{import os} work with the OS

		\code{virtualenv} cmd to create virtual env (solve versioning issues)

		\code{import sys} package to use argv

		\begin{lstlisting}
		__name__ == "__main__" 
		\end{lstlisting}  
		to avoid name mess when calling from cmd

	\subsection{Useful modules}

		\subsubsection{Fichiers}

			\code{f = open('monFichier.txt','r')}

			\subsubsection{csv}

				\code{fich  = csv.reader(f)}

				\code{fich = list(fich)}

		\subsubsection{collections}

			\code{import Counter from collections}

			\code{ctr = Counter(list)} simiilar to a dict with key = the element of the list and values = the number of appearance

			\code{dd = ctr.most\_{}common(n)} returns the n most common stuff in the counter

		\subsubsection{time}

			\code{import time}

			\code{time.cmock()} gets the processor time (useful to commpare execution speed)


		\subsubsection{others}

			\code{datetime} (better for time zones)

			\code{sys} (system function such as argv)

			\code{json}

			\code{json.dumps} for python to json 

			\code{json.loads} for json to python


\section{Python basic programming}

	\subsection{Booleans and logic operators}

		\code{|} or operator

		\code{\&} and operator

	\subsection{built-in functions}

		\code{min}

		\code{max}

		\code{len}

		\code{sum}

		\code{sorted} gets a sorted version of a list

		\code{map(func, li)} applies func to all elemements in li, output type is map

		\code{filter(func, li)} returns the elements in li for which fun(element) is True. Func must returns booleans. output is a filter

		\code{list()} turns an iterable (eg a map) into a list


	\subsection{Numbers and bases}

		\code{int("100",2)}  see 100 as binary, returns 4

		\code{bin(a)} converts a base integer to a binary

		\code{ord(a)} transforms intobase 10, works for caracters, hexadecimal

		\code{'\textbackslash xea'} codes the hexadecimal nber ea


	\subsection{caracters, unicode and byte conversion}

		NB: default encoding in Python 3 is unicode with utf-8 encoding

		NB: ascii is a subset of unicode, limited to 256 caracter (1 octet)

		\code{ord('a')} returns the code in the form of a binary string, ascii or utf-8 by default

		\code{"\textbackslash u1919"} representation of unicode caracter with code 1919

		\code{"text".encode("utf-8")} return a bytes object containing the string encoded in utf-8

		\code{b"text"} turns text into a byte datatype

		\code{byte\_{}stuff.decode("utf-8")} decodes byte using utf-8 encoding
	
	\subsection{Strings}

		\code{str.split(str="", num=string.count(str))} splits a string into a list, by default using space as delimiter

		\code{"c".join(li)} joins the strings in li usuing the string "c" in between

		\code{'sometext'.startwith('abc')} finds if a sting starts with "abc", returns a boolean


	\subsection{Regular expressions}

		\subsubsection{expressions}

			\code{"abc"}

			\code{"a.c"} a - any  letter  - c

			\code{"a[bde]c"} a - b or d or e - c

			\code{abc\/def} abc or def

			\code{"a[d-h]c"} a -any letter between d and h -c

			\code{"\^{ }abc"} abc at the beginning

			\code{"abc\$"} abc at the end

			\code{[6-9]} any figure between 6 and 9

			\code{[\^{}6-9]} anything that is not 6789

			
		\subsubsection{counting}

			\code{a\{3\}} 3 repetitions of a

			\code{a\{3,\}}  at least 3 repetitions of a

			\code{a\{3,6\}} 3 to 6 repetitions of a

			\code{a?} 0 or 1 time a

			\code{a+} at least one time a

			\code{a*} 0 or 1 or any number of a



		\subsubsection{generic types}
			
			\code{\textbackslash d} digit

			\code{\textbackslash D} all but digit

			\code{\textbackslash s} space

			\code{\textbackslash S} all but space

			\code{\textbackslash w} letter or \_{}

			\code{\textbackslash W} opposite of  \code{\textbackslash w}

			\code{\textbackslash n} return

			\code{\textbackslash t} tab

			\code{\textbackslash b} word limit

			\code{\textbackslash B} opposite of  \code{\textbackslash b}

			NB: accents are seen as word limits


		\subsubsection{capturing and use of quastion mark}



		\subsubsection{re module}
		
			\code{import re}

			\code{re.search(regex, string)} ==>returns \code{None} if nothing, match object otherwise

			\code{re.sub(pattern = , repl =, string = )} we want to replace patter in string with repl

	
	
	\subsection{Error handling}

		\subsubsection{try and except}


\begin{lstlisting}
try:
    #some code
except Exception:
    print("there was an error")
\end{lstlisting}

			basic code to catch exceptions


\begin{lstlisting}
try:
    #some code
except Exception as exc:
    print("there was an error")
\end{lstlisting}

			Catches the exception so you can work on it (eg get its type).

		\subsubsection{few error types}

			\code{ValueError} eg when trying to convert some text to integer



\section{Advanced programming}

	\subsection{OOP in Python}

		\subsubsection{Creating a class}


\begin{lstlisting}
class MyClass():
    def __init__(self, stuff):
        self.myStuff = stuff
     def myMethod(self, arg):
     	#method code
\end{lstlisting}

			Here we create a class MyClass with a property mystuff, the  init function with the backslashes is compulsory.
			The class also has a method MyMethod, self is always the first argument of a method

		\subsubsection{Instancing the class}

\begin{lstlisting}
instance_of_myclass = MyClass(onestuff)
\end{lstlisting}


		\subsubsection{overloading operators}

			Interest is that many Python built-in fonction use them, so if you have implemented the comparisons operator, you can use \code{min} and \code{max} on your function

\begin{lstlisting}
def __lt__(self, other):
	#code to define < for this particular class
\end{lstlisting}

			\code{gt} is $>$ (greater than)

			\code{ge} is $\geq$ (greter or equal)

			\code{lt} is $<$ (less than)

			\code{ge} is $\leq$ (less or equal)

			\code{eq} is $==$

			\code{ne} is $neq$ 

		\subsubsection{classmethods}

			Normal method are bound: they need an instance of the class to be called.

			\code{{@}classmethod} keyword to create a class method


	\subsection{Lambda functions}

		function that you write inline and use once, eg in in a function that calls a funtion. The below will return the list of the squares of the elements in li.


\begin{lstlisting}
squares = list(map(lambda x: x**2, li))
\end{lstlisting}


	\subsection{Parallel computing}

		\subsubsection{Thread module}

			\code{import threading} allows to create and use threads

\begin{lstlisting}
mythread = threading.Thread(target=func, args=[func_arguments])
mythread.start()
mythread.join()
\end{lstlisting}

			Starts launch the thread while join allows to bring the thread back to the main thread.

\begin{lstlisting}
lock = threading.Lock()
lock.acquire()
#some operations
lock.release()
\end{lstlisting}

		Locks can be used to stop other thread from accessing something


\section{Data structures}


	\subsection{Dictionary}

		\code{dic = \{\}} creates an empty dictionnary

		\code{dic['mykey'] = value} add a value

		\code{value = dic['mykey']} access a value

		\code{val = dic.get('mykey', False)} returns the value for mykey, False if not in the dict. Default is \code{None}

	\subsection{List}

		dynamic array

		\code{li = [] } creates an empty list

		\code{li = ["a", "b", "c", "d"]} 

		\code{li[2] = val} update the element

		\code{val = li[2]} access the element

		\code{li.append()}  add to a list at the end

		\code{li.insert(n, item)} inserts an item at the nth position in array

		\code{l.delete(1)} delete elements with index 1, reindexes after it

		\code{li.remove(tt)} removes tt (once) if it is in the list, error if it isnt

		\code{li.count(tt)} nber of tt in li

		\code{if tt in li:} test if tt is in li

		\code{len(li)} gives you the length


	\subsection{Sets}

		Unordered collection of unique elements

		\code{s = set([])}


	\subsection{Tupples}
		
		\code{t = ()} creates an empty tupple

		\code{t = ('truc1', truc2')}

		\code{val = t[0]} access an element


	\subsection{enumerate}

		\code{for (i,item) in enumerate(MyItemList)} gets i as the index, item as the data





\section{Maths and Stats in Python}

	\subsection{scypy.stats}

		\code{import scypy.stats as st}

		\code{st.skew(mylist)}

		\code{st.kurtosis(mylist)}

		\code{slope, intercept, r\_{}value, p\_{}value, stderr\_{}slope = st.linregress(x, y)}

		\subsubsection{chi-square}

			\code{chisquare\_{}value, p\_{}value = st.chisquare(observed, expected)} chi-square stuff

			\code{chisq\_{}value, pvalue, df, expected = chi2\_{}contingency(observed)} multi-category chi-square, can take a pandas crosstab \ref{stats:panda:crosstab} as input directly

		\subsubsection{Working with classic probability laws}

			\code(from scipy.stats import binom) binomial law

			\code(binom.pmf(....)) probability mass function

			\code(binom.cdf(....)) cumulative density function


	\subsection{numpy}

		\subsubsection{Lecture Fichiers}
			
\begin{lstlisting}
myData = numpy.genfromtxt("fichier.csv", delimiter=",", skipheader = True, dtype = "U75")}
\end{lstlisting}

		\subsubsection{ndarray}
			
			\code{import numpy as np}

			\code{nmyArray = np.array([1,2,3,4])}

			\code{np.add(array1, array2)} concatenation

			\code{np.sin(array1)} math functions for arrays

			\code{np.max(array2)}

			\code{np.sum(myarray, axis =1)} alloxs to sum along one axis (returns an array)

			\code{myArray.shape} size

			can do some matlab:

			\code{myArray[-1:4:-2]}

			\code{myarray = np.linspace(start, end, num = 50, endpoint=True)} puts fifty value including start and stop (if enpoint is True)

			\code{X, Y = np.meshgrid(x,y)} creates meshgrid matrixes from x, y lists of coordinates

			\code{myArray == 10} array of booleans

			\code{restriction: arrray = unique type}

		\subsubsection{Matrixes and vectors}

			\code{np.asarray([[a,b,c], [d,e,f]], dtype=np.float32)}

			\code{np.dot(A,b)} matrix or vector product

			\code{A.T} transpose

			\code{np.ones((n,m))} matrix full of ones

			\code{np.zeros((n,m))} matrix full of zeros

			\code{np.empty((n,m))} empty matrix

			\code{A = np.concatenate((A,B), axis = 1)} matrix concatenation, axis determines if vertical or horizontal.

		\subsubsection{Numpy stats}

			NB: most numpy function are compatible with pandas objects
			
			\code{np.median(mylist)}

			\code{np.std(mylist)}

			\code{rho, p\_{}value = pearsonr(data1, data2)} correlation and p-value

			\code{cov(data1, data2)[0,1]} covariance, returns a matrix so need indexing


	\subsection{stats in pandas}
		
		\subsubsection{Series and dataframe methods}

			\code{.mean()}

			\code{.kurtosis()}

			\code{.skew()}

			\code{.std()}

			\code{.median()}

		\subsubsection{crosstab}
			\label{stats:panda:crosstab}

			\code{table = pd.crosstab(df["col1"], [df['col2'],df['col3'...]])} gets a cross table for categorical column: how many of each cat of col2 falls into each cat of col1


	\subsection{random package}

		\code{import random as rdm}

		\code{rdm.seed(p)} sets the seed as p, kills the randomness, good if always wanna use the same pseudo random numbers.

		\code{a = rdm.sample(MyList, n)} gets a sample of size n from a list

		\code{a = rdm.randint(p, q)} random number between p and q

		\code{a = rdm.rand(p,q,r...)} $p\times q \times r $ table of random number in $\[0, 1\)$, default size (when empty) is 1

		\code{np.random.permutation(myArray)} combines numpy and random to get rand om permutation on an array

		\code{np.random.choice(data, size=n)} randomly choses n points within datas

	\subsection{Scikit-learn: machine-learning module}

		\subsubsection{Useful functions}

			\code{from sklearn.metrics.pairwise import euclidean\_{}distances}

			\code{euclidean\_{}distances(data1,data2)} euclidean distance, works well with dataset rows, but need to keep only numerical columns

			\code{from sklearn.cros\_{}validation import KFold}

			\code{kf = KFold(sample\_{}size, n\_{}folds=n, random\_{}state=1)} create n folds of test, train lists of index to use on algorithm

			\code{for train,test in kf:}

		\subsubsection{Linear regression}

\begin{lstlisting}
from sklearn.linear_model import LinearRegression
lm = LinearRegression()
lm.fit(predictors, to_predict)
predictions = lm.predict(new_pedictors)
\end{lstlisting}

			The predictor in \code{fit} and in \code{predict} has to be a dataframe. To do that with a single column in a pre-existing df we can trick pandas into returning a df instead of a series by inputting \code{df[['colname']]}.

			\code{lm.coeff\_{}} list of coefficients


		\subsubsection{logistic regression: one class}

\begin{lstlisting}
from sklearn.linear_model import LogisticRegression
regressor = LogisticRegression()
regressor.fit(predictors, to_predict)
pred_probs =  regressor.predict_proba(new_predictors)
pred =  regressor.predict_proba(new_predictors)
\end{lstlisting}

			Same retrictrion on the inputs as for the linear regression. 

			\code{predict\_{}proba()} returns a proba to be in the class for single-classification problem. The output is a $2 \times input-size$ array, with proba to have 0 on column $[:,0]$ and proba to have 1 on column $[:,1]$.

			\code{predict()} returns the predicted labels.

			See doc for multi-class problems.

			\code{fpr, tpr, thresholds = sklearn.metrics.roc\_{}curve(labels, proba)} studies indicator of the classificator depending on chosen threshold.

			\code{auc\_{}score = roc\_{}auc\_{}score(proba, labels)} gets the auc score


		\subsubsection{clustering}

\begin{lstlisting}
from sklearn.cluster import KMeans
kmeans_model = KMeans(n_clusters=N, random_state=1)
distances = kmeans_model.fit_transform(data)
labels = kmeans_model.labels_
\end{lstlisting}

			k-means cluster with N clusters. Better than brutal approach where the clusters depend heavily on the initialization.

			\code{distances} is a numpy array, for each row in data, it gives the distance to each of the clusters. 

			The \code{random\_{}state} initialize a random state for the cluster, fixing it allows to get the same results every time the algo is ran

			\code{labels\_{}} contains the cluster to which each row in data is associated

		\subsubsection{Decision trees}

\begin{lstlisting}
from sklearn.tree import DecisionTreeClassifier
clf = DecisionTreeClassifier(random_state=1)
clf.fit(df[['col1','col2'...]],income['col_target'])
predictions = clf.predict(data)
\end{lstlisting}

			Classification decision tree, the class for regression is \code{ DecisionTreeRegressor}.

			\code{clf = DecisionTreeClassifier(random\_{}state=1, max\_{}depth = 4, min\_{}samples\_{}split = 25)} adding constraints on the tree can reduce over-fitting

		\subsubsection{Random forest}

			NB: different techniques

			\begin{description}

			\item[bagging:] generate several trees byt randomely sampling the training set and take the average of the tree rerults.

			\item{[andom features:] putting random constraints on the maximization of the information gain, eg by letting only pick from 2 randomly selected columns at each step.

			\end{description}

\begin{lstlisting}
from sklearn.ensemble import RandomForestClassifier
clf = RandomForestClassifier(n_estimators=10, random_state=1, min_samples_leaf=75)
clf.fit(data, labels)
\end{lstlisting}

	Creates a random forest classifier using both bagging and random features. For a regression model, use class \code{RandomForestRegressor}.


	\subsection{statsmodel.api}

		\subsubsection{linear regression}

			\code{import statsmodels.api as sm}

			\code{X = sm.add\_{}constant(X)} adds a column of ones (constant term)

			\code{linear = sm.OLS(y,X)} clasical least square fit

			\code{linearfit = linear.fit} stocks the model

			\code{linearfit.summary()} info about the model

				\code{linearfit.params} model parameters


\section{Pandas module}

	\code{import pandas as pd}

	\subsection{Load and write csv}

		\code{df = pandas.read\_{}csv("monFichier.csv", index\_{}col = True)} creates a dataframe from a csv file, \code{index\_{}col} indicates wether the first column should be used as index

		\code{df.to\_{}csv("file.csv", index=False)}


	\subsection{useful functions}
		
		\code{pd.isnull()}

		\code{pd.to\_{}datetime(data, )} take a series, string, list, tuple...  as arg 

	\subsection{DataFrame object}

		\code{df= pd.DataFrame(li[1:], columns = li[0] )} allows to create a df form a list of list, here the first row of the list is a header so we put it into columns


		\code{dataframe["colname"] = dataframe["colname"].astype(float)} column type conversion.

		\subsubsection{Columns and rows}
			
			\code{df["nomdelacolonne"]} gets a column as a series data type

			\code{df[ ["colname1", "colname2" ] ]} gets several columns as a DataFrame data type 

			\code{df["nouveau nom"] = mySerie} adds a column

			\code{df3 = pd.concat([df, df2], axis=1)} aggregates 2 dataframe

			\code{.head(n)} n first rows

			\code{.columns} list of columns

			\code{.shape} sizes  ==> [0] for nber of row, [1] for col

			\code{.index} indexes

			\code{.loc[i]} gets a row as a series data type

			\code{.count()} with 0 or 1 nber of rows/columns

			NB: can do some matlab on loc too

			NB: loc works with index, may go off the rails when removing some rows, to access based on position, use iloc 

			\code{.dtype} series of the data type for each column

			\code{df.sort("nom de colonne", inplace=True, ascending=False)}

		\subsubsection{index}
			
			\code{.index} indexes

			\code{.reset\_{}index(drop = True)} reset the indexes to start at 0 and go one by one

			\code{.set\_{}index("nomcolonne", drop = True, Inplace = False)} returns new df indexed by the chosen column (drop = True means this column  is then removed in the new one)

			NB: to modify an index, good solutuion is to turn it into a lit using \code{.tolist()}, to modify the list and then to reassign to the index using \code{myDF.index = myList} (conversion to index type is handled autmatically)

		\subsubsection{drop and fill}

			\code{.drop('nom de colonne', axis = 1)} kill a columns

			\code{.dropna()} removes rows with missing data

			\code{df['col'] = df['col'].fillna(val)} fills NA values with val

			\code{dropna.(subset=['nomcolonne1','nomcolonne2'])}

			\code{dropna.(axis=1)} removes colums with missing val


		\subsubsection{apply}
			
			\code{df2 = df.apply(mafonction)} function applied to each column. If function return a single value, then output is series, If function returns a series, output is df

			\code{ser = df.apply(mafonction, axis = 1)} function applied to each row, output is Series

		\subsubsection{pivot table for dataframe}

\begin{lstlisting}
mean_age_by_class = df.pivot_table(index="class", values="age", 
				aggfunc=numpy.mean) 
\end{lstlisting}

			==> Series of age mean by class

\begin{lstlisting}
statsdf.pivot_table(index="pclass", values=["age", "size"], 
			aggfunc=np.mean)
\end{lstlisting}

			 ==> dataframe with mean age and size by class

		\subsubsection{Preparing for ML algo}

			\code{df2 = pd.get\_{}dummies(df["col"], prefix="pref")} creates a dataframe with new columns with 0 and 1 from a multi-category column with numbers
			
			\code{col = pandas.Categorical.from\_{}array(df["colname"])} changes a categorical column into a number column

			\code{col.codes} returns the label data

			\code{df2 = df.sample(frac=bag\_{}proportion, replace=True, random\_{}state=i)} sampling with replacement (eg to create random forest with bagging technique)

	\subsection{Series}

		NB: acts as both a dictionnary and a list

		NB: extends numpy ndarray operation, matlab-like stuffand boolean stuff


		\subsubsection{creation and indexing}
			
			\code{myserie = Series(index = liste1, data = liste2)}

			\code{myserie.index} gets the index as an Indexes object

			\code{.sort\_{}index()} sort by index

			\code{.sort\_{}values()} sort by values

		
		\subsubsection{Operations}
			
			\code{mySerie2 = mySerie / 1000 OR 12 + mySerie OR etc} scalar

			\code{mySerie3 = mySerie * mySerie2} line by line

			\code{.min(), .max(), ...}

			\code{.idxmin()} gets the argmin, ie the index for the lowest value

			\code{.mean()} removes the missing values 

			\code{.isnull} column of boolean as output

			\code{.tolist()}

			\code{.unique()} returns a series with duplicates removed

			\code{.to\_{}dict()} converts to dictionary



\section{Vizualization}

	\subsection{Matplotlib}

		\subsubsection{pyplot basic plots}
	
			\begin{lstlisting}
				import matplotlib.pyplot as plt
			\end{lstlisting}

			\code{plt.style.use("fivethirtyeight")} change style, before creating plot

			\code{plt.scatter(xdata,ydata, color = 'red', c = categories)}  scatter plot, the optional c should be a categorical column, it will assign different colors to the label 

			\code{plt.show()} has to be added to show the graph

			NB: add several scatter with same x values before show to plot several data as y

			\code{plt.plot(xdata,ydata)} creates a line plot

			\code{plt.bar(xdata,ydata)} creates a bar chart

			\code{plt.axvline(myfloat, color='r')} add verical line 

			\code{plt.barh(ydata,xdata)} creates a horizontal bar chart

			\code{plt.title("montitre")} add a title

			\code{plt.xlabel("monlabel")} add a label for x-axis

			\code{plt.ylabel("monlabel")}

		\subsubsection{pyplot Figure object}

			\code{fig = plt.figure(figsize=(w,h))} sizes in inch

			\code{.figsize(w,h)} size in inches

			\code{.dpi()} dots per inch

			\code{.add\_{}subplot(nb of rows,nb of columns, number of the plot)}

		\subsubsection{pyplot Subplot and Axes object}

			\code{ax = fig.addsubplot(1,1,1)} return an Axes object

			\code{ax.set\_{}xlim([min,max])} min and max of x axe

			\code{ax.set\_{}ylim([min,max])} min and max of y axe

			\code{ax.scatter(xdata, ydata, color=mycolor, marker=mymarker)} add points

			\code{ax.set\_{}xlabel("xlegend")}

			\code{ax.set\_{}ylabel("ylegend")}

			\code{ax.set\_{}title("titre")}

			==> wrappup: \code{ax.set(xlim =..., ylim=...)}

		\subsubsection{plotting vectors in pyplot}

			\code{plt.quiver(X, Y, U, V, angles='xy', scale\_{}units='xy', scale=1)} 
			X is the x origin of the vectors
			Y is the y origin of the vectors
			U is the moves of each vector on the x axis
			V is the moves of each vector on the y axis
			==> to plot 3 vectors, X, Y... will be list of length 3



	\subsection{Plots with pandas}

		\subsubsection{plots on Dataframe object}

			\code{pd.scatter\_{}matrix(df)} plots each series vs the others, diag is histogram

			\code{df.plot(kind='...')} allows to plot each series in the df in one plot

		\subsubsection{histograms in panda (derived from matplotlib)}

\begin{lstlisting}
df.hist(column = ['nomcolonne1','nomcolonne2'],layout=(2,1), grid=False, bins = 20)
\end{lstlisting}

			=>layout gives the position of the 2 graphs
			=>grid indicates if background has a grid
			=>bins number of bars

		\subsubsection{boxplots in panda (derived form matplotlib)}

			boxplot shows quartiles, if col 1 takes categorical values and col2 numerical, you'll get the quartiles of the values taken by col2 for each category in col1 

\begin{lstlisting}
df[['col1', 'col2']].boxplot(by='col1')
\end{lstlisting}


	\subsection{Basemap: doing maps}
	
		map plotting derived of matplotlib, needs to import matplotlib.pyplot

		\code{from mpl\_{}toolkits.basemap import Basemap}

		\code{m = Basemap(projection = 'merc', llcrnrlat = -80, urcrnrlat=80, llcrnrlon=-180,urcrnrlon=180)} instancing with mercator projection, the figures give the min and max

		\code{x, y = m(longitudes, latitudes)} convert from long, to cartesian

		\code{m.scatter(x,y, s = 1)} s is size of the dots

		\code{m.drawcoastlines()} add the coastlines

	\subsection{Seaborn (complement for matplotlib, easy vizualization)}

		simply importing it changes the look of the plots for the better

		==> matplotlib + pandas for exploration

		==> seaborn customized and taylor-made vizualization with simple API

		\code{import seaborn as sns}

		\code{sns.set\_{}style(style = 'dark')} allows to change the style

		\code{sns.axlabel('nameOfXAxis', 'nameOfYAxis')} legend

		\subsubsection{histograms}

			\code{sns.distplot(myseries,kde=False)}

			\code{sns.plt.show()}

			==>kde plot or dont plot the kernel distribution function

		\subsubsection{boxplot}
			\code{sns.boxplot(x=myserie1, y=myserie2, ax =myAxes)}

		\subsubsection{pairplot}
			plots each column against each column in a matrix, histo for the diagonal

			\code{sns.pairplot(df, vars=['nomcolonne1', 'nomcolonne2', 'nomcolonne3'])}


\section{Get web pages and data from API}

	\subsection{Requests: work with API}

		\subsubsection{params and headers}
			are defined in the API documentation
			usually headers are used to authenticate the user (see below)

		\subsubsection{get request}

			\code{req = request.get("http...")} obtain data, there is an optional 

			dictionnary of parameters, and headers

			\code{req.content} gets you the content of the request

			\code{req.headers} dictionary of meta data on the request

			\code{req.headers['content-type']} gives you the content type

			\code{data = req.json()} gets the data in the form of a python object (dict, list of dict etc)
			\code{req.status\_{}code}

			==>200 = ok

			==>401 = not authticated

			==>404 = not found

		\subsubsection{post request}

			can post some jason using the post method

			\code{mydict =\{'name':'some name'\}}
			\code{req = requests.post('http...', json = mydict, headers = ...)} ==> when succesful, the status will be 201

		\subsubsection{modification request}

			\code{request.patch} change parts of an object

			\code{request.put} send the full object to update it

			\code{request.delete} to dlete stuff

		\subsubsection{authentication}
			
			NB: using username + psswd is shut if someones get your script

			token: similar to a password but with defined rights to get accesse through the api. Passed through a header in request, headers is a dictionnary
			
			\code{headers = \{"Authorization": "token thetoken"\}}

			\code{response = requests.get("https://...", headers=headers)}	


\section{Beautifulsoup : parsing html}

	\subsection{create a parser}
		
		\code{resp = requests.get("some simple html page")}

		\code{parser = BeautifulSoup(resp.content, 'html.parser')}

	\subsection{Access stuff}

		\code{parser.body.p.text} accesses the stuff

		\code{parser.find\_{}all("body")[0].find\_{}all("p")} gets a list

		\code{parser.find\_{}all("p", id="first")} filters by id

		\code{parser.find\_{}all("p", class\_{} ="first")} filters by class

		\code{parser.select("\#truc")} use CSS selectors (ici id = "truc")

		NB: can do nesting like in CSS too



\section{Accessing databases in Python}

	\subsection{sqlite3: sqlite DB}

	\subsubsection{connecting}

		\code{import sqlite3 as sql}

		\code{conn = sql.connect('mydb.db')} ===> conn is an sqlite3.connection objecct

	\subsubsection{running requests}

		\subsubsection{cursor object}
			\code{cursor = conn.cursor()}

			\code{cursor.execute("query typed as a string")}

			\code{res = cursor.fetchall()} ==>res is a list of tuple

			\code{res = cursor.fetchone()} returns one result + increments the cursor

			\code{res = cursor.fetchmany(n)} returns n results + increments the cursors

	\subsubsection{skip the cursor}
			\code{res = conn.execute("query typed as a string").fetchall())}

	\subsubsection{closing the connection}

		allows to save the changes (sqlite3 only) and free accesses for other users

		\code{conn.close()}

		\subsection{PostgreSQL: psycopg2}
			similar to sqlite3 in the use

		\subsubsection{connecting}
			
			\code{import psycopg2}

			\code{conn = psycopg2.connect("dbname=.... user=...")} ==> need user to handle permissions

		\subsubsection{transaction}
	
			more sophisticated than SQL: when doing changes on a data base, a transaction is open. If some of the changes fail, the all transaction fail. 
			\code{conn.commit()} to save the changes, have to commit

			\code{conn.rollback()} to cancel the changes have tto rollback

			if neither is done, changes remain pending

		\subsubsection{autocommit}
			\code{conn.autocommit = True} changes are saved immediately; necessary to create a database






